<html>
<head>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://dev.hel.fi/~kotkanen/lib/Leaflet.helsinki-tiles.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-dvf/0.3.0/css/dvf.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-dvf/0.3.0/leaflet-dvf.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.2/lodash.min.js"></script>
    <style type="text/css">
    .info, .yearsel {
        padding: 6px 8px;
        font: 14px/16px Arial, Helvetica, sans-serif;
        background: white;
        background: rgba(255,255,255,0.8);
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
        border-radius: 5px;
    }
    .info h4 {
        margin: 0 0 5px;
        color: #777;
    }

    .legend {
        line-height: 18px;
        color: #555;
    }
    .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.7;
    }
    #container {
        width: 100%;
        height: 100%;
    }
    #map {
        width: 100%;
        height: 70%;
    }
    #plot {
        width: 100%;
        height: 30%;
    }
    </style>
</head>
<body>
<div id="container">
    <div id="map"></div>
    <br>
    <div id="plot"></div>
</div>
<script>
window.options = {}
window.options.years = ['2015', '2012', '2009', '2006']
window.options.currentlayer = null
window.options.year_layers = {}
window.options.area_data = {}
window.options.geoms = []

// hard coded to fit the safe_by_year.json data format
function object_to_cols(ob) {
    var keys = []
    var vals_safe = []
    var vals_unsafe = []
    for (var year in ob) {
        keys.push(year)
        vals_safe.push(ob[year].safe)
        vals_unsafe.push(ob[year].unsafe)
    }
    return {year: keys, safe: vals_safe, unsafe: vals_unsafe}
}

// hard coded to fit the safe_by_year.json data format
function find_min_max(ob) {
    var min = 100
    var max = 0
    for (var area in ob) {
        // console.log(ob[area])
        for (var year in ob[area]) {
            // console.log(ob[area][year].unsafe)
            if (ob[area][year].unsafe < min) {
                min = ob[area][year].unsafe
            }
            if (ob[area][year].unsafe > max) {
                max = ob[area][year].unsafe
            }
        }
    }
    return {min: min, max:max}
}

function remove_datalayers() {
    for (var layer in window.options.year_layers){
        map.removeLayer(window.options.year_layers[layer])
    }
    if (typeof(info) == 'object') {
        info.update()
    }
}

function highlight_feature(e) {
    var layer = e.target
    layer.setStyle({
        weight: 5,
        color: '#666',
        dashArray: '',
        fillOpacity: 0.7
    })

    if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
        layer.bringToFront();
    }
    info.update(layer.feature)
}

function reset_hightlight(e) {
    // window.options.currentlayer && window.options.currentlayer.resetStyle(e.target)
    var layer = e.target
    layer.setStyle({
        color: 'white',
        weight: 2,
        dashArray: '3'
    })
    info.update()
}

function clickFeature(e) {
    console.log(e)
}

function change_year_overlay(year) {
    remove_datalayers()
    window.options.year_layers[year].addTo(map)
    window.options.currentlayer = window.options.year_layers[year]
    window.options.currentyear = year
}

function on_each_feature(feature, layer) {
    layer.on({
        mouseover: highlight_feature,
        mouseout: reset_hightlight,
        click: clickFeature
    })
}

function value_to_color(min_value, max_value) {
    return new L.HSLHueFunction(
			new L.Point(min_value,120),
			new L.Point(max_value,0))

    // https://github.com/humangeo/leaflet-dvf/blob/master/examples/js/colors.js
    // return new L.PiecewiseFunction([new L.HSLLuminosityFunction([min_value,1], [20,0.5], {outputHue: 60}), new L.HSLHueFunction([20,60], [max_value, 0])])
}

// load safety data, find min and max values and create color interpolator
var data_promise = $.getJSON("data/safe_by_year.json")
    .done(function(data) {
        window.options.safe_data = data.data
        var bounds = find_min_max(data.data)
        window.options.color_interpolator = value_to_color(bounds.min, bounds.max)
        // console.log(window.options.polator.evaluate(30))
    })

// get area geometries, inject safety data into geojson array and store it as the global "area_data"
var geometry_promise = $.getJSON("https://api.hel.fi/servicemap/v1/administrative_division/?type=3&page_size=100&geometry=True")
    .done(function(data) {
        data.results.map(function(area) {
            area.properties = {}
            area.properties.safety = window.options.safe_data[area.origin_id]
            area.properties.safety_cols = object_to_cols(area.properties.safety)
            window.options.area_data[area.origin_id] = area
            area.type = "Feature"
            area.geometry = area.boundary
            window.options.geoms.push(area)
        })
        console.log("area geometry loaded and data injected")
    })

// SET UP MAP
var map = L.map.Helsinki("map", {background: "servicemap"})
map.setZoom(8)

// LEGEND
data_promise.done(function(data) {
    var legend = L.control({position: 'bottomright'})
    var bounds = find_min_max(data.data)
    legend.onAdd = function (map) {
        var div = L.DomUtil.create('div', 'info legend'),
            grades = _.range(bounds.min, bounds.max, 5)
            labels = []
        // loop through our density intervals and generate a label with a colored square for each interval
        for (var i = 0; i < grades.length; i++) {
            div.innerHTML +=
                '<i style="background:' + window.options.color_interpolator.evaluate(grades[i] + 1) + '"></i> ' +
                grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] + '<br>' : '+')
        }
        return div
    }
    legend.addTo(map)
})


// wait on the areas being loaded again and stored as a global
// then construct yearly layer groups
geometry_promise.done(function() {
    // make a layergroup for each year to hold all the colored areas
    for (var year in window.options.years) {
        year = window.options.years[year]
        var year_layer = L.geoJSON(window.options.geoms, {
            style: function(feat) {
                var year_i = feat.properties.safety_cols.year.findIndex(function(elem){return elem===year})
                var color = window.options.color_interpolator.evaluate(feat.properties.safety_cols.unsafe[year_i])
                return {
                    fillColor: color,
                    color: 'white',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.7,
                    dashArray: '3'
                }
            },
            onEachFeature: on_each_feature
        })
        window.options.year_layers[year] = L.layerGroup().addLayer(year_layer)
    }

    // YEAR SELECT
    var yearsel = L.control()
    yearsel.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'yearsel')
        for (var year in window.options.years) {
            console.log(window.options.years[year]=="2015" ? "true" : "false")
            this._div.innerHTML += "<label><input id='" + "select-" + window.options.years[year] + "' type='radio' name='yearselect' value='" + window.options.years[year] + "'/>" + window.options.years[year] + "</label>"
        }
        return this._div
    }
    yearsel.addTo(map)
    $("input").change(function(event) {
        change_year_overlay(event.target.value)
    })
    $("input[value=2015]").prop("checked", true).change()


    // INFO
    var info = L.control()
    info.onAdd = function (map) {
        this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
        this.update()
        return this._div
    }
    // method that we will use to update the control based on feature properties passed
    info.update = function (props) {
        this._div.innerHTML = '<h4>Turvattomuuden kokijoita vuonna ' + (window.options.currentyear) + '</h4>' +
            (props ? '<b>' + props.name.fi + '</b><br />' + props.properties.safety[window.options.currentyear].unsafe.toFixed(2) + ' %'
            : 'Siirrä hiiri peruspiirin päälle')
    }
    info.addTo(map)
    window.info = info
})

//PLOT
plot = document.getElementById('plot');

Plotly.plot( plot, [{
    x: [1, 2, 3, 4, 5],
    y: [1, 2, 4, 8, 16] }], {
    margin: { t: 0 } } )

</script>
</body>
</html
